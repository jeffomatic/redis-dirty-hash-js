// Generated by CoffeeScript 1.6.3
(function() {
  var RedisDirtyHash, assert, redisClient, testHelper;

  assert = require('assert');

  testHelper = require('./test_helper');

  RedisDirtyHash = require('../lib/redis_dirty_hash');

  redisClient = testHelper.getRedisClient();

  describe('RedisDirtyHash', function() {
    beforeEach(function(done) {
      var _this = this;
      this.hash = new RedisDirtyHash({
        redis: redisClient,
        key: 'test'
      });
      return redisClient.flushdb(function(err, result) {
        if (err != null) {
          throw err;
        }
        return done();
      });
    });
    describe('#get', function() {
      beforeEach(function() {
        this.hash.set('foo', 'bar');
        return this.hash.set('foobar', 'barfoo');
      });
      describe('single-key param', function() {
        it('should return values set with #set', function() {
          assert.equal(this.hash.get('foo'), 'bar');
          return assert.equal(this.hash.get('foobar'), 'barfoo');
        });
        return it('should return undefined for values that were not set', function() {
          return assert(this.hash.get('foobarfoo') == null);
        });
      });
      describe('array param', function() {
        it('should return values as a hash', function() {
          assert.deepEqual(this.hash.get(['foo']), {
            foo: 'bar'
          });
          return assert.deepEqual(this.hash.get(['foobar', 'foo']), {
            foobar: 'barfoo',
            foo: 'bar'
          });
        });
        return it('should return undefined for values that were not set', function() {
          return assert.deepEqual(this.hash.get(['foobar', 'foobarfoo']), {
            foobar: 'barfoo',
            foobarfoo: void 0
          });
        });
      });
      return describe('empty param', function() {
        return it('should return everything as a hash', function() {
          return assert.deepEqual(this.hash.get(), {
            foobar: 'barfoo',
            foo: 'bar'
          });
        });
      });
    });
    describe('#set', function() {
      describe('key/value pair syntax', function() {
        beforeEach(function() {
          this.hash.set('foo', 'bar');
          return this.hash.set('foobar', 'barfoo');
        });
        it('should set the appropriate internal properties', function() {
          assert.equal(this.hash.get('foo'), 'bar');
          return assert.equal(this.hash.get('foobar'), 'barfoo');
        });
        it('should set the dirty flags', function() {
          assert(this.hash.dirty.foo);
          return assert(this.hash.dirty.foobar);
        });
        return it('should not set the dirty flag if the value did not change', function(done) {
          var _this = this;
          return this.hash.save(function(err) {
            if (err != null) {
              throw err;
            }
            assert(!_this.hash.dirty.foo);
            _this.hash.set('foo', 'bar');
            assert(!_this.hash.dirty.foo);
            return done();
          });
        });
      });
      return describe('hash syntax', function() {
        beforeEach(function() {
          return this.hash.set({
            foo: 'bar',
            foobar: 'barfoo'
          });
        });
        it('should set the appropriate internal properties', function() {
          assert.equal(this.hash.get('foo'), 'bar');
          return assert.equal(this.hash.get('foobar'), 'barfoo');
        });
        it('should set the dirty flags', function() {
          assert(this.hash.dirty.foo);
          return assert(this.hash.dirty.foobar);
        });
        return it('should not set the dirty flag if the value did not change', function(done) {
          var _this = this;
          return this.hash.save(function(err) {
            if (err != null) {
              throw err;
            }
            assert(!_this.hash.dirty.foo);
            assert(!_this.hash.dirty.foobar);
            _this.hash.set({
              foo: 'bar',
              foobar: 'barfoo'
            });
            assert(!_this.hash.dirty.foo);
            assert(!_this.hash.dirty.foobar);
            return done();
          });
        });
      });
    });
    return describe('#fetch', function() {
      var _this = this;
      describe('with no pre-existing data in Redis', function() {
        it('should be okay if the key does not exist in Redis', function(done) {
          return this.hash.fetch(function(err) {
            if (err != null) {
              throw err;
            }
            return done();
          });
        });
        it('should have empty properties', function(done) {
          var _this = this;
          return this.hash.fetch(function(err) {
            if (err != null) {
              throw err;
            }
            assert(_this.hash.get('foo') == null);
            return done();
          });
        });
        return describe('with pre-existing unpersisted data', function() {
          return it('should clear unpersisted data', function(done) {
            var _this = this;
            this.hash.set({
              foo: 'bar'
            });
            return this.hash.fetch(function(err) {
              if (err != null) {
                throw err;
              }
              assert(_this.hash.get('foo') == null);
              return done();
            });
          });
        });
      });
      describe('with pre-existing data in Redis', function() {
        beforeEach(function(done) {
          var _this = this;
          this.hash.set({
            foo: 'bar',
            foobar: 'barfoo'
          });
          return this.hash.save(function(err) {
            if (err != null) {
              throw err;
            }
            return done();
          });
        });
        it('should retrieve saved data', function(done) {
          var _this = this;
          this.fetchedHash = new RedisDirtyHash({
            redis: redisClient,
            key: this.hash.opts.key
          });
          return this.fetchedHash.fetch(function(err) {
            if (err != null) {
              throw err;
            }
            assert.deepEqual(_this.fetchedHash.get(), {
              foo: 'bar',
              foobar: 'barfoo'
            });
            return done();
          });
        });
        return describe('with pre-existing unpersisted data', function() {
          beforeEach(function(done) {
            var _this = this;
            this.fetchedHash = new RedisDirtyHash({
              redis: redisClient,
              key: this.hash.opts.key
            });
            this.fetchedHash.set('foo', 'changed!');
            this.fetchedHash.set('oof', 'rab');
            return this.fetchedHash.fetch(function(err) {
              if (err != null) {
                throw err;
              }
              return done();
            });
          });
          it('should clear the dirty state', function() {
            return assert.deepEqual(this.fetchedHash.dirty, {});
          });
          return it('should clear unpersisted data', function() {
            assert.equal(this.fetchedHash.get('foo'), 'bar');
            return assert(this.fetchedHash.get('oof') == null);
          });
        });
      });
      describe('#save', function() {
        beforeEach(function(done) {
          var _this = this;
          this.hash.set({
            foo: 'bar',
            foobar: 'foobar'
          });
          return this.hash.save(function(err) {
            if (err != null) {
              throw err;
            }
            return done();
          });
        });
        it('should persist fetchable changes', function(done) {
          var newHash,
            _this = this;
          newHash = new RedisDirtyHash({
            redis: redisClient,
            key: this.hash.opts.key
          });
          return newHash.fetch(function(err) {
            if (err != null) {
              throw err;
            }
            assert.deepEqual(newHash.get(), {
              foo: 'bar',
              foobar: 'foobar'
            });
            return done();
          });
        });
        it('should clear the dirty state', function() {
          return assert.deepEqual(this.hash.dirty, {});
        });
        it('should not need Redis if the object is not dirty', function(done) {
          var _this = this;
          this.hash.opts.redis = null;
          return this.hash.save(function(err) {
            if (err != null) {
              throw err;
            }
            return done();
          });
        });
        return it('by default, should delete keys that are undefined', function(done) {
          var _this = this;
          this.hash.set({
            foo: void 0
          });
          return this.hash.save(function(err) {
            if (err != null) {
              throw err;
            }
            return redisClient.hget(_this.hash.opts.key, 'foo', function(err, v) {
              if (err != null) {
                throw err;
              }
              assert(v == null);
              return done();
            });
          });
        });
      });
      describe('#destroy', function() {
        return it('should eliminate persisted changes', function(done) {
          var _this = this;
          this.hash.set({
            foo: 'bar',
            foobar: 'foobar'
          });
          return this.hash.save(function(err) {
            if (err != null) {
              throw err;
            }
            return _this.hash.destroy(function(err) {
              if (err != null) {
                throw err;
              }
              return _this.hash.fetch(function(err) {
                if (err != null) {
                  throw err;
                }
                assert.deepEqual(_this.hash.get(), {});
                return done();
              });
            });
          });
        });
      });
      return describe('serialization and deserialization', function() {
        return it('by default, should JSON serialize/deserialize all values', function(done) {
          var values,
            _this = this;
          values = {
            foo: 'bar',
            foobar: [1, 2, 3],
            barfoo: false,
            oof: 1,
            blah: null
          };
          this.hash.set(values);
          return this.hash.save(function(err) {
            var otherHash;
            if (err != null) {
              throw err;
            }
            otherHash = new RedisDirtyHash({
              redis: redisClient,
              key: _this.hash.opts.key
            });
            return otherHash.fetch(function(err) {
              if (err != null) {
                throw err;
              }
              assert.deepEqual(otherHash.get(), values);
              return done();
            });
          });
        });
      });
    });
  });

}).call(this);
